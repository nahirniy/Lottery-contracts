// SPDX-License-Identifier: MIT
pragma solidity ^0.8.21;

import {AccessControl} from "@openzeppelin/contracts/access/AccessControl.sol";
import {Address} from "@openzeppelin/contracts/utils/Address.sol";
import {IERC165} from "@openzeppelin/contracts/utils/introspection/IERC165.sol";
import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import {SafeERC20} from "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import {IRootsyCampaign} from "./interface/IRootsyCampaign.sol";
import {ILottery} from "./interface/ILottery.sol";
import {IRandomGetter} from "./interface/IRandomGetter.sol";
import {IRootsyTicket} from "./interface/IRootsyTicket.sol";

/**
 * @title Lottery contract
 * @notice Manages lottery functionality including ticket registration, initialization, running, and rewarding winners.
 * @notice The lottery has 3 tiers type - jackpot, random and fixed. 
 * @notice Winners are selected from registered tickets using a specific algorithm that relies on a random number generated
 * by the Chainlink VRF to ensure randomness, then receive a reward in their wallet.
 */
contract Lottery is AccessControl, ILottery {
    using SafeERC20 for IERC20;

    /// @notice Сonstant that contains the REGISTRAR role. Owner of this role can registet ticket contracts.
    bytes32 public constant REGISTRAR_ROLE = keccak256("REGISTRAR");
    /// @notice Сonstant that contains the REWARDER role. Owner of this role can reward winners who exceeded the lottery cap.
    bytes32 public constant REWARDER_ROLE = keccak256("REWARDER_ROLE");
    /// @notice Basis points. Used to calculate the amount of winners.
    uint256 public constant BIPS = 100_00;

    /// @inheritdoc ILottery
    uint32 public mintDeadline;
    /// @inheritdoc ILottery
    uint32 public burnDeadline;
    /// @inheritdoc ILottery
    uint32 public lotteryTime;

    /// @notice Maximum amount a single winner can receive.
    uint256 public lotteryCap;
    /// @notice Total supply of tickets participating in the lottery.
    uint256 public lotteryTicketsTotalSupply;
    /// @notice Random number generated by chainlink VRF.
    uint256 public randomSalt;
    /// @notice Request ID by which it is possible to get a random number.
    uint256 public requestRandomNumberId;

    /// @notice Addresses of organizations participating in the lottery.
    address[] public organizations;
    /// @notice An array of each organization's shares.
    uint[] public organizationSharesForFixedTiers;

    /// @notice The amount of initialized organizations
    uint public initializedOrganizationsCount;
    /// @inheritdoc ILottery
    mapping(address => bool) public isRegisteredTicket;
    /// @inheritdoc ILottery
    mapping(address => bool) public isOrganizationAdded;
    /// @inheritdoc ILottery
    mapping(address => address[]) public organizationTicketsContracts;
    /// @inheritdoc ILottery
    mapping(address => TicketRange) public organizationTicketsRange;
    /// @notice Array containing tickets of each campaign and TicketRange. 
    CampaignTickets[] public allCampaignTickets;

    /// @notice Array containing configuration of lottery tiers
    /// @dev Each `Tier` struct defines a tier with attributes such as type, percentage share of winners, amount of winners, and reward amount.
    Tier[] public tiers;
    /// @notice The amount of tiers for that rewards have already been sent to winners.
    uint256 public processedTiersCount;
    /// @notice Token contract for rewards.
    IERC20 public rewardToken;
    /// @notice randomGetter contract that is responsible for obtaining a random number.
    IRandomGetter public randomGetter;
    /// @notice Array contains the lottery ticket IDs that.
    uint256[] public winners;
    /// @notice Array contains the lottery ticket IDs that won more than the lottery cap.
    uint256[] public overCapWinners;

    /// @inheritdoc ILottery
    mapping(uint256 => uint256) public overCapWinnerAmount;
    /// @inheritdoc ILottery
    mapping(uint256 => uint256) public winnerAmount;
    /// @inheritdoc ILottery
    mapping(uint256 => uint256[]) public tierWinners;
    /// @notice Flag indicating whether the lottery has been completely processed (all tiers).
    bool public lotteryProcessed;
    
    /**
     * @notice Constructor function to initialize the Lottery contract.
     * @param _defaultAdmin The address of the admin this contract.
     * @param _registrar The address of the registrar role (expected to be the factory contract).
     * @param _randomGetter The address of the contract providing random numbers.
     * @param _mintDeadline The timestamp indicating the deadline for minting tickets.
     * @param _burnDeadline The timestamp indicating the deadline for burning tickets.
     * @param _lotteryTime The timestamp indicating the time when the lottery can be run.
     * @dev Reverts if the provided time values are incorrect.
     */
    constructor(
        address _defaultAdmin,
        address _registrar,
        address _randomGetter,
        uint32 _mintDeadline,
        uint32 _burnDeadline,
        uint32 _lotteryTime
    ) {
        if (block.timestamp > _mintDeadline || _mintDeadline > _burnDeadline || _burnDeadline > _lotteryTime) {
            revert IncorrectValue("Incorrect time values");
        }

        mintDeadline = _mintDeadline;
        burnDeadline = _burnDeadline;
        lotteryTime = _lotteryTime;

        randomGetter = IRandomGetter(_randomGetter);

        _setupRole(DEFAULT_ADMIN_ROLE, _defaultAdmin);
        _setupRole(REWARDER_ROLE, _defaultAdmin);
        _setupRole(REGISTRAR_ROLE, _registrar); //expected to be factory contract
    }

    /// @inheritdoc ILottery
    function registerTicketContract(address _ticketContract) external onlyRole(REGISTRAR_ROLE) {
        if (IERC165(_ticketContract).supportsInterface(type(IRootsyTicket).interfaceId) == false) {
            revert InterfaceNotSupported();
        }
        if(isRegisteredTicket[_ticketContract]){
            revert IncorrectValue("Ticket contract is already registered");
        }
        address organization = IRootsyTicket(_ticketContract).getOrganisation();
        if (!isOrganizationAdded[organization]) {
            organizations.push(organization);
            isOrganizationAdded[organization] = true;
        }
        isRegisteredTicket[_ticketContract] = true;
        organizationTicketsContracts[organization].push(_ticketContract);
        emit RegisterTicketContract(organization, _ticketContract);
    }

    /// @inheritdoc ILottery
    function setupLottery(
        address _rewardToken,
        uint _lotteryCap,
        Tier[] memory _tiers,
        uint[] memory _organizationSharesForFixedTiers
    ) external onlyRole(DEFAULT_ADMIN_ROLE) {
        if (block.timestamp > lotteryTime) {
            revert IncorrectCondition("Can't setup after lottery time");
        }
        if (Address.isContract(_rewardToken) == false) {
            revert IncorrectValue("Reward token is not a contract");
        }
        if (_organizationSharesForFixedTiers.length != organizations.length) {
            revert IncorrectValue("Incorrect organization shares count");
        }
        if (_lotteryCap == 0) {
            revert IncorrectValue("Lottery cap can't be zero");
        }

        rewardToken = IERC20(_rewardToken);
        lotteryCap = _lotteryCap;

        for (uint i; i < _tiers.length; i++) {
            Tier memory tier = _tiers[i]; 
            if (i == 0) {
                if (tier.tierType != TierType.Jackpot) {
                    revert IncorrectValue("First tier must be Jackpot");
                }
                if (tier.winnersCount != 1) {
                    revert IncorrectValue("There must be 1 winner in Jackpot tier");
                }
            } else {
                if (_tiers[i - 1].tierType > _tiers[i].tierType) {
                    revert IncorrectValue("Incorrect tier order");
                }
                
                if (tier.tierType == TierType.Random) {
                    if (tier.winnersShare == 0) {
                        revert IncorrectValue("Winners share can't be 0 for random tier");
                    }
                    tier.winnersCount = lotteryTicketsTotalSupply * tier.winnersShare / BIPS;
                } else {
                    if (tier.winnersCount == 0) {
                        revert IncorrectValue("Winners count can't be 0 for fixed tier");
                    }

                    uint totalOrganizationWinnersCount = 0;
                    for (uint o = 0; o < _organizationSharesForFixedTiers.length; o++) {
                        uint organizationWinnersCount = tier.winnersCount * _organizationSharesForFixedTiers[o] / BIPS;
                        if (organizationWinnersCount == 0) {
                            revert IncorrectValue("Organization winners count can't be 0 for fixed tier");
                        }
                        totalOrganizationWinnersCount += organizationWinnersCount;
                    }

                    if (totalOrganizationWinnersCount != tier.winnersCount) {
                        revert IncorrectValue("Total organization winners count does not match tier winners count");
                    }
                }
            }
            
            if (tier.winnersCount > 100) {
                revert IncorrectValue("Winners count can't exceed 100 per tier");
            }
            if (tier.rewardAmount == 0) {
                revert IncorrectValue("Incorrect tier values");
            }
            tiers.push(_tiers[i]);

        }

        uint totalShares;
        for (uint i; i < _organizationSharesForFixedTiers.length; i++) {
            if (_organizationSharesForFixedTiers[i] == 0 || _organizationSharesForFixedTiers[i] > BIPS) {
                revert IncorrectValue("Incorrect organization shares");
            }
            totalShares += _organizationSharesForFixedTiers[i];
        }
        if (totalShares != BIPS) {
            revert IncorrectValue("Total shares sum must be 100%");
        } 
        organizationSharesForFixedTiers = _organizationSharesForFixedTiers;
        emit LotterySetup(_rewardToken, tiers, organizationSharesForFixedTiers);
    }

    /// @inheritdoc ILottery
    function initializeLottery(uint organizationsCount) external {
        if (block.timestamp < burnDeadline) {
            revert IncorrectCondition("Burn period not finished yet");
        }
        if (tiers.length == 0){
            revert IncorrectCondition("Lottery is not set up");
        }
        if (initializedOrganizationsCount == organizations.length) {
            revert ActionPerformed("Lottery already initialized");
        }

        uint initializedOrganizationIndex = initializedOrganizationsCount; //cache value for gas optimization
        if (organizationsCount == 0 || organizationsCount > organizations.length - initializedOrganizationIndex) {
            organizationsCount = organizations.length - initializedOrganizationIndex;
        }

        uint startIndex;
        uint lotteryTotalSupply;
        for (uint o = initializedOrganizationIndex; o < initializedOrganizationIndex + organizationsCount; o++) {
            address[] memory organizationTickets = organizationTicketsContracts[organizations[o]];
            organizationTicketsRange[organizations[o]].firstLotteryTicketId = lotteryTotalSupply;
            for (uint t; t < organizationTickets.length; t++) {
                uint campaignTotalSupply = IRootsyTicket(organizationTickets[t]).totalSupply();
                lotteryTotalSupply = startIndex + campaignTotalSupply;
                allCampaignTickets.push(CampaignTickets(organizationTickets[t], TicketRange(startIndex, lotteryTotalSupply - 1)));
                //if (o != organizations.length - 1 && t != organizationTickets.length - 1) {
                    startIndex = lotteryTotalSupply;
                //}
            }
            organizationTicketsRange[organizations[o]].lastLotteryTicketId = lotteryTotalSupply - 1;
            initializedOrganizationsCount++;
        }
        lotteryTicketsTotalSupply += lotteryTotalSupply;

        uint totalWinnersCount;
        for (uint i; i < tiers.length; i++) {
            if (tiers[i].tierType == TierType.Random) {    
                tiers[i].winnersCount = lotteryTicketsTotalSupply * tiers[i].winnersShare / BIPS;
            }
            totalWinnersCount += tiers[i].winnersCount;
        }

        if (initializedOrganizationsCount == organizations.length && lotteryTicketsTotalSupply < totalWinnersCount) {
            revert IncorrectCondition("Not enough tickets for the number of winners");
        }

        emit LotteryInitialized(organizations.length);
    }

    /// @inheritdoc ILottery
    function runLottery() external {
        if (block.timestamp < lotteryTime) {
            revert IncorrectCondition("Lottery time not reached yet");
        }
        if (requestRandomNumberId != 0) {
            revert ActionPerformed("Lottery already run");
        }
        if (initializedOrganizationsCount != organizations.length) {
            revert IncorrectCondition("Lottery is not fully initialized");
        }
        requestRandomNumberId = randomGetter.requestRandomNumber();
    }

    /// @inheritdoc ILottery
    function rewardWinners(uint tiersCount) external {
        if (randomSalt == 0) randomSalt = randomGetter.getRandomNumber(requestRandomNumberId);

        if (randomSalt == 0) {
            revert IncorrectCondition("Request is pending or lottery is not run");
        }
        if (lotteryProcessed) {
            revert ActionPerformed("Lottery already processed");
        }
        uint processedTiersCountCache = processedTiersCount; //cache value for gas optimization
        if (tiersCount == 0 || tiersCount > tiers.length - processedTiersCountCache) {
            tiersCount = tiers.length - processedTiersCountCache;
        }
        for (uint t = processedTiersCountCache; t < processedTiersCountCache + tiersCount; t++) {
            Tier memory tier = tiers[t];
            if (tier.tierType != TierType.Fixed) {
                uint tierTotalRewardAmount = _rewardWinnersForTier(0, lotteryTicketsTotalSupply - 1, t, tier);
                emit TierProcessed(t, address(0), tierTotalRewardAmount);
            } else {
                for (uint o; o < organizations.length; o++) {
                    uint startTicketId = organizationTicketsRange[organizations[o]].firstLotteryTicketId;
                    uint endTicketId = organizationTicketsRange[organizations[o]].lastLotteryTicketId;

                    if (endTicketId >= startTicketId) {
                        uint organizationWinnersCount = tier.winnersCount * organizationSharesForFixedTiers[o]  / BIPS;
                        Tier memory tierForFixed = Tier(tier.tierType, 0, organizationWinnersCount, tier.rewardAmount);
                        uint tierTotalRewardAmount = _rewardWinnersForTier(startTicketId, endTicketId, t, tierForFixed);
                        emit TierProcessed(t, organizations[o], tierTotalRewardAmount);
                    }
                }
            }
            processedTiersCount++;
        }
        if (processedTiersCount == tiers.length) {
            lotteryProcessed = true;
            emit LotteryFinished();
        }
    }

    /// @inheritdoc ILottery
    function rewardOverCapWinners(uint256[] memory lotteryTicketIds) external onlyRole(REWARDER_ROLE) {
        for (uint256 w = 0; w < lotteryTicketIds.length; w++) {
            _rewardOverCapWinner(lotteryTicketIds[w]);
        }
    }

    /// @inheritdoc ILottery
    function rewardOverCapWinner(uint256 lotteryTicketId) external onlyRole(REWARDER_ROLE) {
        _rewardOverCapWinner(lotteryTicketId);
    }

    /// @inheritdoc ILottery
    function withdrawTokens(address token, address receiver, uint256 amount) external onlyRole(DEFAULT_ADMIN_ROLE) {
        IERC20(token).safeTransfer(receiver, amount);
    }

    /// @inheritdoc ILottery
    function withdrawAllTokens() external onlyRole(DEFAULT_ADMIN_ROLE) {
        uint256 balance = rewardToken.balanceOf(address(this));
        rewardToken.safeTransfer(msg.sender, balance);
    }

    /// @inheritdoc ILottery
    function getUnderlyingTicket(uint lotteryTicketId) public view returns (address, uint256) {
        uint256 lower = 0;
        uint256 upper = allCampaignTickets.length - 1;
        while (upper > lower) {
            uint256 center = upper - (upper - lower) / 2; // ceil, avoiding overflow
            CampaignTickets memory tickets = allCampaignTickets[center];
            if (lotteryTicketId >= tickets.ticketRange.firstLotteryTicketId && 
                tickets.ticketRange.lastLotteryTicketId >= lotteryTicketId
            ) {
                return 
                    (tickets.campaignTicketContract, 
                    tickets.ticketRange.lastLotteryTicketId - lotteryTicketId + 1);

            } else if (tickets.ticketRange.firstLotteryTicketId < lotteryTicketId) {
                lower = center;
            } else {
                upper = center - 1;
            }
        }
        CampaignTickets memory tickets_ = allCampaignTickets[lower];
        return (tickets_.campaignTicketContract,  tickets_.ticketRange.lastLotteryTicketId - lotteryTicketId + 1);
    }

    /// @inheritdoc ILottery
    function getLotteryTicketId(address campaign, uint256 ticketId) public view returns (uint256) {
        address ticketContract = IRootsyCampaign(campaign).ticketsContract();

        uint256 lotteryTicketId;
        uint256 amountTicketsBefore;
        for (uint256 i = 0; i < allCampaignTickets.length; i++) {
            if (allCampaignTickets[i].campaignTicketContract == ticketContract) {
                lotteryTicketId = amountTicketsBefore + ticketId + 1;
                break;
            }
            amountTicketsBefore = allCampaignTickets[i].ticketRange.lastLotteryTicketId;
        }

        return lotteryTicketId;
    }

    /// @inheritdoc ILottery
    function getTierWinners(uint256 tierId) external view returns (uint256[] memory) {
        return tierWinners[tierId];
    }

    /// @inheritdoc ILottery
    function getTier(uint tierIndex) public view returns (Tier memory) {
        return tiers[tierIndex];
    }

    /// @inheritdoc ILottery
    function getAllTiers() public view returns (Tier[] memory) {
        return tiers;
    }

    /// @inheritdoc ILottery
    function getAllOrganizations() public view returns (address[] memory) {
        return organizations;
    }

    /// @inheritdoc ILottery
    function getAllWinners() external view returns (uint256[] memory) {
        return winners;
    }

    /// @inheritdoc ILottery
    function getAllOverCapWinners() external view returns (uint256[] memory) {
        return overCapWinners;
    }

    /// @inheritdoc ILottery
    function getTiersCount() public view returns (uint) {
        return tiers.length;
    }

    /// @inheritdoc ILottery
    function getOrganizationsCount() public view returns (uint) {
        return organizations.length;
    }

    /// @inheritdoc ILottery
    function getWinnersCount() external view returns (uint256) {
        return winners.length;
    }
    
    /// @inheritdoc ILottery
    function getOverCapWinnersCount() external view returns (uint256) {
        return overCapWinners.length;
    }

    /// @inheritdoc ILottery
    function getOrganizationTicketsContracts(address organization) public view returns (address[] memory) {
        return organizationTicketsContracts[organization];
    }

    /// @inheritdoc ILottery
    function getOrganizationSharesForFixedTiers() public view returns (uint[] memory) {
        return organizationSharesForFixedTiers;
    }

    /// @inheritdoc ILottery
    function getAllCampaignTickets() public view returns (CampaignTickets[] memory) {
        return allCampaignTickets;
    }

    /**
     * @notice Recursively checks if the ticket with the given ID is not a winner.
     * @param firstTicketId The starting ID of the lottery tickets range.
     * @param lastTicketId The ending ID of the lottery tickets range.
     * @param lotteryTicketId The ID of the lottery ticket to check.
     * @param attempts The current number of attempts (should start with 0).
     * @return The ID of the first non-winning ticket found after the provided ID, or -1 if it loops for the second time.
     */
    function _checkTicketIsNotWinner(
        uint firstTicketId,
        uint lastTicketId,
        uint lotteryTicketId,
        uint attempts
    ) internal view returns (int) {
        if (attempts > lastTicketId - firstTicketId + 1) {
            return -1;
        }

        if (winnerAmount[lotteryTicketId] > 0) {
            uint newId = lotteryTicketId + 1;
            if (newId > lastTicketId) {
                newId = firstTicketId;
            }
            return _checkTicketIsNotWinner(firstTicketId, lastTicketId, newId, attempts + 1);
        } else {
            return int(lotteryTicketId);
        }
    }

    /**
     * @notice This function randomly selects winners from registered tickets based on a random number and rewards them.
     * @param startTicketId The starting ID of the lottery tickets range.
     * @param endTicketId The ending ID of the lottery tickets range.
     * @param tierIndex The index of the tier.
     * @param tier The details of the tier.
     * @return tierTotalRewardAmount The total amount rewarded for the tier.
     */
    function _rewardWinnersForTier(
        uint startTicketId,
        uint endTicketId,
        uint tierIndex,
        Tier memory tier
    ) internal returns (uint tierTotalRewardAmount) {
        uint ticketsInRange = endTicketId - startTicketId + 1;

        if (tier.tierType == TierType.Fixed && ticketsInRange < tier.winnersCount) {
            tier.winnersCount = ticketsInRange;
        }

        for(uint w; w < tier.winnersCount; w++) {
            uint lotteryTicketId = uint(keccak256(abi.encode(randomSalt, tierIndex, w))) % ticketsInRange + startTicketId;

            int newLotteryTicketId;
            if (tier.tierType == TierType.Fixed) {
                newLotteryTicketId = _checkTicketIsNotWinner(startTicketId, endTicketId, lotteryTicketId, 0);
            } else {
                newLotteryTicketId = _checkTicketIsNotWinner(0, lotteryTicketsTotalSupply - 1, lotteryTicketId, 0);
            }

            if (newLotteryTicketId == -1) continue;
            lotteryTicketId = uint(newLotteryTicketId);

            (address campaignTicketContract, uint campaignTicketId) = getUnderlyingTicket(lotteryTicketId);
            address owner = IRootsyTicket(campaignTicketContract).ownerOf(campaignTicketId);
            
            if (tier.rewardAmount > lotteryCap) {
                overCapWinnerAmount[lotteryTicketId] = tier.rewardAmount;
                overCapWinners.push(lotteryTicketId);
            } else {
                rewardToken.safeTransfer(owner, tier.rewardAmount);
            }

            winnerAmount[lotteryTicketId] = tier.rewardAmount;
            winners.push(lotteryTicketId);
            tierWinners[tierIndex].push(lotteryTicketId);
            emit WinnerDefined(owner, lotteryTicketId, campaignTicketContract, campaignTicketId, uint256(tier.tierType), tier.rewardAmount);
            tierTotalRewardAmount += tier.rewardAmount;
        }
    }

    /**
     * @notice Private function to reward a single over-cap winner.
     * @param lotteryTicketId The ID of the lottery ticket to reward.
     */
    function _rewardOverCapWinner(uint256 lotteryTicketId) private {
        uint256 rewardAmount = overCapWinnerAmount[lotteryTicketId];

        if (rewardAmount == 0) {
            revert IncorrectValue("Token ID does not exist");
        }
        
        (address campaignTicketContract, uint campaignTicketId) = getUnderlyingTicket(lotteryTicketId);
        address owner = IRootsyTicket(campaignTicketContract).ownerOf(campaignTicketId);

        rewardToken.safeTransfer(owner, rewardAmount);
        delete overCapWinnerAmount[lotteryTicketId];
        for (uint256 i = 0; i < overCapWinners.length; i++) {
            if (overCapWinners[i] == lotteryTicketId) {
                overCapWinners[i] = overCapWinners[overCapWinners.length - 1];
                overCapWinners.pop();
                break;
            }
        }
    }

     /// @inheritdoc IERC165
    function supportsInterface(
        bytes4 interfaceId
    ) public view override(AccessControl, IERC165) returns (bool) {
        return interfaceId == type(ILottery).interfaceId || 
            super.supportsInterface(interfaceId);
    }
}